/* parser.cup - Grammar specification for the custom language with AST support */
import java_cup.runtime.*;
import java.util.*;

/* Terminal definitions */
terminal VAR, INTEGER_TYPE, BOOLEAN_TYPE, REAL_TYPE, ARRAY, RECORD, TRUE, FALSE, IS;
terminal IF, THEN, ELSE, END, FOR, IN, LOOP, WHILE, ROUTINE, RETURN;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, ASSIGN, EQUAL, GREATER_THAN, LESS_THAN;
terminal AND, OR, XOR, NOT;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA, DOT, RANGE, COLON, SEMICOLON;
terminal String IDENTIFIER;
terminal Integer NUMBER;
terminal Double REAL;

/* Non-terminal definitions */
non terminal ProgramNode Program;
non terminal List<ASTNode> ProgramElements;
non terminal ASTNode ProgramElement;
non terminal DeclarationNode Declaration;
non terminal TypeNode Type;
non terminal StatementNode Statement;
non terminal StatementBlockNode StatementBlock;
non terminal StatementNode SimpleStatement;
non terminal StatementNode CompoundStatement;
non terminal ExpressionNode Expression;
non terminal List<ExpressionNode> ExpressionList;
non terminal FunctionNode Function;
non terminal ExpressionNode Variable;
non terminal List<DeclarationNode> DeclarationList; 

/* Precedence rules */
precedence left OR, AND, XOR;
precedence left EQUAL, LESS_THAN, GREATER_THAN;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence right NOT;

/* Grammar rules */
Program ::= ProgramElements:e 
           {: RESULT = new ProgramNode(e); :};

ProgramElements ::= ProgramElements:e1 ProgramElement:e2
                  {: e1.add(e2); RESULT = e1; :}
                  | ProgramElement:e
                  {: RESULT = new ArrayList<>(Arrays.asList(e)); :};

ProgramElement ::= Declaration:d SEMICOLON
                  {: RESULT = d; :}
                | Statement:s
                  {: RESULT = s; :}
                | Function:f
                  {: RESULT = f; :};

Type ::= INTEGER_TYPE
        {: RESULT = new IntegerTypeNode(); :}
      | BOOLEAN_TYPE
        {: RESULT = new BooleanTypeNode(); :}
      | REAL_TYPE
        {: RESULT = new RealTypeNode(); :}
      | ARRAY LBRACKET NUMBER:size RBRACKET Type:elementType
        {: RESULT = new ArrayTypeNode(size, elementType); :};

Declaration ::= VAR IDENTIFIER:id COLON Type:type IS Expression:expr
               {: RESULT = new DeclarationNode(id, type, expr); :}
              | VAR IDENTIFIER:id COLON Type:type
              {: RESULT = new DeclarationNode(id, type, null); :};

DeclarationList ::= DeclarationList:fields Declaration:d SEMICOLON
                    {: fields.add(d); RESULT = fields; :}
                  | Declaration:d SEMICOLON
                    {: RESULT = new ArrayList<>(Arrays.asList(d)); :}
                  | DeclarationList:fields Declaration:d
                    {: fields.add(d); RESULT = fields; :}
                  | DeclarationList:fields COMMA Declaration:d
                    {: fields.add(d); RESULT = fields; :}
                  | Declaration:d
                    {: RESULT = new ArrayList<>(Arrays.asList(d)); :};

StatementBlock ::= StatementBlock:s1 Statement:s2
                 {: s1.getStatements().add(s2); RESULT = s1; :}
                 | Statement:s
                 {: RESULT = new StatementBlockNode(new ArrayList<>(Arrays.asList(s))); :};

Statement ::= SimpleStatement:s SEMICOLON
             {: RESULT = s; :}
           | CompoundStatement:cs
             {: RESULT = cs; :};

SimpleStatement ::= Variable:s1 ASSIGN Expression:expr
                   {: RESULT = new AssignmentNode(s1, expr); :}
                 | RETURN Expression:expr
                   {: RESULT = new ReturnNode(expr); :};

Variable ::= IDENTIFIER:id
            {: RESULT = new IdentifierNode(id); :}
          | IDENTIFIER:id LBRACKET Expression:index RBRACKET
            {: RESULT = new ArrayAccessNode(new IdentifierNode(id), index); :};

CompoundStatement ::= IF LPAREN Expression:cond RPAREN THEN StatementBlock:thenStmt ELSE StatementBlock:elseStmt END
                      {: RESULT = new IfElseNode(cond, thenStmt, elseStmt); :}
                    | IF LPAREN Expression:cond RPAREN THEN StatementBlock:thenStmt END
                      {: RESULT = new IfElseNode(cond, thenStmt); :}
                    | WHILE LPAREN Expression:cond RPAREN LOOP StatementBlock:body END
                      {: RESULT = new WhileLoopNode(cond, body); :}
                    | FOR IDENTIFIER:id IN LBRACKET Expression:start RANGE Expression:end RBRACKET LOOP StatementBlock:body END
                      {: RESULT = new ForLoopNode(new IdentifierNode(id), start, end, body); :};

Expression ::= Expression:left PLUS Expression:right
              {: RESULT = new BinaryOpNode(left, right, "+"); :}
            | Expression:left MINUS Expression:right
              {: RESULT = new BinaryOpNode(left, right, "-"); :}
            | Expression:left AND Expression:right
              {: RESULT = new BinaryOpNode(left, right, "AND"); :}
            | Expression:left OR Expression:right
              {: RESULT = new BinaryOpNode(left, right, "OR"); :}
            | Expression:left XOR Expression:right
              {: RESULT = new BinaryOpNode(left, right, "XOR"); :}
            | Expression:left MULTIPLY Expression:right
              {: RESULT = new BinaryOpNode(left, right, "*"); :}
            | Expression:left DIVIDE Expression:right
              {: RESULT = new BinaryOpNode(left, right, "/"); :}
            | Expression:left EQUAL Expression:right
              {: RESULT = new BinaryOpNode(left, right, "=="); :}
            | Expression:left GREATER_THAN Expression:right
              {: RESULT = new BinaryOpNode(left, right, ">"); :}
            | Expression:left LESS_THAN Expression:right
              {: RESULT = new BinaryOpNode(left, right, "<"); :}
            | NOT Expression:expr
              {: RESULT = new UnaryOpNode(expr, "NOT"); :}
            | TRUE
              {: RESULT = new BooleanNode(true); :}
            | FALSE
              {: RESULT = new BooleanNode(false); :}
            | NUMBER:num
              {: RESULT = new NumberNode(num); :}
            | REAL:real
              {: RESULT = new RealNode(real); :}
            | Variable:v
              {: RESULT = v; :}
            | LPAREN Expression:expr RPAREN
              {: RESULT = expr; :}
            | LBRACKET ExpressionList:list RBRACKET
              {: RESULT = new ExpressionListNode(list); :};

ExpressionList ::= ExpressionList:el COMMA Expression:expr
                   {: el.add(expr); RESULT = el; :}
                 | Expression:expr
                   {: RESULT = new ArrayList<>(Arrays.asList(expr)); :};

Function ::= ROUTINE IDENTIFIER:id LPAREN DeclarationList:params RPAREN COLON Type:returnType IS StatementBlock:body END
             {: RESULT = new FunctionNode(id, params, returnType, body); :}
           | ROUTINE IDENTIFIER:id LPAREN RPAREN COLON Type:returnType IS StatementBlock:body END
             {: RESULT = new FunctionNode(id, new ArrayList<>(), returnType, body); :};