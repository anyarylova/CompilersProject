/* parser.cup - Grammar specification for the custom language */
import java.util.*;  // for List
import java_cup.runtime.*;

terminal VAR, INTEGER_TYPE, BOOLEAN_TYPE, REAL_TYPE, ARRAY, RECORD, TRUE, FALSE, IS;
terminal IF, THEN, ELSE, END, FOR, IN, LOOP, WHILE, ROUTINE, RETURN;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, ASSIGN, EQUAL, GREATER_THAN, LESS_THAN;
terminal AND, OR, XOR, NOT;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA, DOT, RANGE, COLON, SEMICOLON;
terminal String IDENTIFIER;
terminal Integer NUMBER;
terminal Double REAL;

non terminal ProgramNode Program;
non terminal DeclarationNode Declaration;
non terminal StatementNode Statement;
non terminal ExpressionNode Expression;
non terminal TypeNode Type;
non terminal FunctionNode Function;

/* Define precedences */
precedence left OR, AND, XOR;
precedence left EQUAL, LESS_THAN, GREATER_THAN;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE;
precedence right NOT;

/* Grammar rules */
Program ::= Declaration:d SEMICOLON
          {: RESULT = new ProgramNode(Collections.singletonList(d)); :}
          | Statement:s SEMICOLON
          {: RESULT = new ProgramNode(Collections.singletonList(s)); :}
          | Function:f SEMICOLON
          {: RESULT = new ProgramNode(Collections.singletonList(f)); :};

Declaration ::= VAR IDENTIFIER:id COLON Type:t IS Expression:e
              {: RESULT = new DeclarationNode(id, t, e); :};

Type ::= INTEGER_TYPE
       {: RESULT = new IntegerTypeNode(); :}
       | BOOLEAN_TYPE
       {: RESULT = new BooleanTypeNode(); :}
       | REAL_TYPE
       {: RESULT = new RealTypeNode(); :}
       | ARRAY LBRACKET NUMBER:n RBRACKET Type:t
         {: RESULT = new ArrayTypeNode(n, t); :}
       | RECORD Declaration:d END
         {: RESULT = new RecordTypeNode(Collections.singletonList(d)); :};

Statement ::= IDENTIFIER:id ASSIGN Expression:e
            {: RESULT = new AssignmentNode(new IdentifierNode(id), e); :}
            | IF Expression:e THEN Statement:s1 ELSE Statement:s2 END
              {: RESULT = new IfElseNode(e, s1, s2); :}
            | WHILE Expression:e LOOP Statement:s END
              {: RESULT = new WhileLoopNode(e, s); :}
            | FOR IDENTIFIER:id IN Expression:e1 RANGE Expression:e2 LOOP Statement:s END
              {: RESULT = new ForLoopNode(new IdentifierNode(id), e1, e2, s); :}
            | RETURN Expression:e
              {: RESULT = new ReturnNode(e); :};

Expression ::= Expression:left PLUS Expression:right
             {: RESULT = new BinaryOpNode(left, right, "+"); :}
             | Expression:left MINUS Expression:right
             {: RESULT = new BinaryOpNode(left, right, "-"); :}
             | Expression:left MULTIPLY Expression:right
             {: RESULT = new BinaryOpNode(left, right, "*"); :}
             | Expression:left DIVIDE Expression:right
             {: RESULT = new BinaryOpNode(left, right, "/"); :}
             | Expression:left EQUAL Expression:right
             {: RESULT = new BinaryOpNode(left, right, "=="); :}
             | Expression:left GREATER_THAN Expression:right
             {: RESULT = new BinaryOpNode(left, right, ">"); :}
             | Expression:left LESS_THAN Expression:right
             {: RESULT = new BinaryOpNode(left, right, "<"); :}
             | NOT Expression:e
             {: RESULT = new UnaryOpNode(e, "not"); :}
             | TRUE
             {: RESULT = new BooleanNode(true); :}
             | FALSE
             {: RESULT = new BooleanNode(false); :}
             | NUMBER:n
             {: RESULT = new NumberNode(n); :}
             | REAL:r
             {: RESULT = new RealNode(r); :}
             | IDENTIFIER:id
             {: RESULT = new IdentifierNode(id); :}
             | LPAREN Expression:e RPAREN
             {: RESULT = e; :};

Function ::= ROUTINE IDENTIFIER:id LPAREN RPAREN IS Declaration:d SEMICOLON Statement:s END
            {: RESULT = new FunctionNode(id, d, s); :};
